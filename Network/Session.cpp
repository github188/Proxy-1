//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : Session.cpp
//  @ Date : 2011-1-21
//  @ Author : chenjinyi
//
//


#include "Session.h"

#include <assert.h>
#include <netinet/in.h>
#include <sys/ioctl.h>

#include "jsiomodel.h"
#include "TaskDispatcher.h"

#include "../Log/Log.h"

CSession::CSession(CNetwork* pNetwork):
m_state(NETWORK_STATE_UNCONNECTED),
m_role(NETWORK_ROLE_UNKNOWN),
m_type(NETWORK_TYPE_UNKNOWN),
m_ip(NULL),
m_port(0),
m_listenPort(0),
m_nFd(-1),
m_tmpRecvBuffer(NULL),
m_pPacket(NULL),
m_nPacketLen(PACKET_LENGHT_UNKNOWN),
m_network(pNetwork),
m_npacketType(0)
{
    m_tmpRecvBuffer = new char[DEFAULT_RECV_LEN];
    m_pPacket = new char[DEFAULT_PACKET_MAXLEN];

    m_ip = new char[64];
}

CSession::~CSession()
{
    if (m_nFd > 0)
    {
        close(m_nFd);
    }

    delete[] m_ip;

    delete[] m_tmpRecvBuffer;
    delete[] m_pPacket;

    m_network = NULL;
}

//返回实际发送的长度，如果没有可发送的数据，返回1.
//返回<=0,认为连接中断
int CSession::Send(int fd)
{
    if (fd < 0)
    {
        return -1;
    }

    int ret = 1;
    CMutexLock lock(m_writeMutex);

    size_t readableBytes = m_writeBuffer.ReadableBytes();
    if (readableBytes > 0)
    {
        size_t sendBytes = readableBytes>=DEFAULT_SEND_LEN?DEFAULT_SEND_LEN:readableBytes;
        ret = write(fd, m_writeBuffer.BeginRead(), sendBytes);
        if (ret > 0)
        {
            m_writeBuffer.Retrieve(ret);
        }
        else
        {
            printf("CSession::Send send len = %d\n", ret);
        }
    }
    else
    {
        if (m_network->GetIOMode() != NULL)
        {
            m_network->GetIOMode()->FdDisable(m_nFd, JSWR);
        }
    }

    return ret;
}


int CSession::Send(const char* pData, int dataSize)
{
    if (pData == NULL || dataSize <= 0)
    {
        return -1;
    }

    if (GetState() != NETWORK_STATE_CONNECTED || m_nFd < 0)
    {
        printf("int CSession::Send(const char* pData, int dataSize) unconnected !!!!, fd = %d\n\n\n", m_nFd);
        return -1;
    }

    CMutexLock lock(m_writeMutex);

    if (m_writeBuffer.ReadableBytes() >= (unsigned)MAX_SEND_LIST_SIZE)
    {
        //不能清空发送队列，如果对方一个数据包只接收到了一部分，清空发送队列，可能导致包错位
        //只能等待发送队列变小
        WARNLOG("warning send buffer full, max size = %d\n", MAX_SEND_LIST_SIZE);
        return -1;
    }

    m_writeBuffer.Append(pData, dataSize);

    if (m_network->GetIOMode() != NULL)
    {
        m_network->GetIOMode()->FdEnable(m_nFd, JSWR);
    }

    //printf("write buffer size = %d\n", m_writeBuffer.ReadableBytes());

    return 0;
}


int CSession::NetDatainQueue(int fd)
{
    int n = DEFAULT_RECV_LEN;
    if (ioctl(fd, FIONREAD, &n) < 0)
        return -1;
    return n;
}


int CSession::Recv(int fd)
{
    if (fd < 0)
    {
        printf("CSession::Recv fd = %d\n", fd);
        return -1;
    }

    int rlen = recv(fd, m_tmpRecvBuffer, DEFAULT_RECV_LEN, 0);
    if (rlen <= 0)
    {
        printf("recv len = %d, fd = %d\n", rlen, fd);
        return rlen;
    }

    m_readMutex.Lock();
    m_readBuffer.Append(m_tmpRecvBuffer, rlen);

    bool bError = false;

    //***********************
    //TLV数据格式接收
    //T      L      V
    //4字节      4字节       L字节
    //***********************
    int curNetDataLen = 0;

    while (!(((curNetDataLen = m_readBuffer.ReadableBytes()) < 8)
            && (m_nPacketLen == PACKET_LENGHT_UNKNOWN)))
    {
        if (m_nPacketLen == PACKET_LENGHT_UNKNOWN)
        {
            if (curNetDataLen < 8)
            {
                break;
            }
            else
            {
                m_readBuffer.Get(m_pPacket, 8);

            	static unsigned short a = 0xcc;
            	static unsigned char ch = (unsigned char)a;
            	static bool bLittleEndian = ((ch | a) == 0xcc);

            	if (*(int*)m_pPacket == 0x55aa55aa && bLittleEndian)
            	{
            		m_nPacketLen = *(int*) (m_pPacket + 4);

            		m_npacketType = 0x55aa55aa;
            	}
            	else
            	{
            		m_nPacketLen = ntohl(*(int*) (m_pPacket + 4));

            		//printf("parse type = %d, len = %d\n", ntohl(*(int*) (m_pPacket)), m_nPacketLen);

            		m_npacketType = ntohl(*(int*)m_pPacket);
            	}
            }
        }

        if (m_nPacketLen != PACKET_LENGHT_UNKNOWN)
        {
            if (m_nPacketLen == 0)
            {
                DispatchPacket(m_pPacket, 8);
                m_nPacketLen = PACKET_LENGHT_UNKNOWN;
                continue;
            }

            //包长不合理，中断
            if (m_nPacketLen < -1 || m_nPacketLen >= UNREACHABLE_PACKET_LEN)
            {
                //printf("recv packet, packet len get unreachable len, break!!! packet type = %d, packet len = %d\n", m_npacketType, m_nPacketLen);
                if (m_npacketType == 0x55aa55aa)
                {
                    ERRLOG("recv packet, packet len get unreachable len, break!!! packet type = 0x55aa55aa, packet len = %d\n", m_nPacketLen);
                }
                else
                {
                    ERRLOG("recv packet, packet len get unreachable len, break!!! packet type = %d, packet len = %d\n", m_npacketType<< 1 >> 1, m_nPacketLen);
                }
                bError = true;
                m_nPacketLen = PACKET_LENGHT_UNKNOWN;
                break;
            }

            //接收到的数据不够一个包长，中断此次接收，等待下次数据到来
            if ((unsigned)m_nPacketLen > m_readBuffer.ReadableBytes())
            {
                break;
            }

            //网络数据足够多，接收一个完整包
            if ((unsigned)m_nPacketLen <= m_readBuffer.ReadableBytes())
            {
                if (m_nPacketLen <= DEFAULT_PACKET_MAXLEN-8)
                {
                    m_readBuffer.Get(m_pPacket+8, m_nPacketLen);

                    DispatchPacket(m_pPacket, m_nPacketLen+8);
                    m_nPacketLen = PACKET_LENGHT_UNKNOWN;
                }
                else
                {
                    char *pBigPacket = new char[m_nPacketLen+8];

                    memcpy(pBigPacket, m_pPacket, 8);

                    m_readBuffer.Get(pBigPacket + 8, m_nPacketLen);
                    //printf("recv len = %d\n", rlen);

                    DispatchPacket(pBigPacket, m_nPacketLen + 8);
                    m_nPacketLen = PACKET_LENGHT_UNKNOWN;

                    delete[] pBigPacket;
                }
            }
        }
    }


    m_readMutex.Unlock();


    if (bError)
    {
        Shutdown();
    }

    return 1;
}



void CSession::DispatchPacket(const char* pData, int packetLen)
{
    if (m_network != NULL && m_network->GetTaskDispatcher() != NULL)
    {
        m_network->GetTaskDispatcher()->Dispatch(this, pData, packetLen);
    }
}



void CSession::Shutdown()
{
    SetState(NETWORK_STATE_UNCONNECTED);

    if (m_network->GetIOMode() != NULL)
    {
        m_network->GetIOMode()->DelFd(m_nFd);
    }
}

